diff --git a/security/manager/ssl/ExternalPasswordPrompt.cpp b/security/manager/ssl/ExternalPasswordPrompt.cpp
new file mode 100644
index 0000000..8a69577
--- /dev/null
+++ b/security/manager/ssl/ExternalPasswordPrompt.cpp
@@ -0,0 +1,158 @@
+#include "mozilla/Preferences.h"
+#include "nsCOMPtr.h"
+#include "nsIProperties.h"
+#include "nsIFile.h"
+#include "nsString.h"
+#include "nsXULAppAPI.h"
+#include "secport.h"
+#include <iostream>
+#include <string>
+#include <cstdlib>
+
+#if defined(XP_UNIX)
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <string.h>
+#include <errno.h>
+#endif
+
+using namespace std;
+using namespace mozilla;
+
+#define OUTPUT_PROGRAM			"ExternalPasswordPrompt"
+#define OUTPUT_PREFIX 			OUTPUT_PROGRAM ": "
+#define OUTPUT_PREFIX_PID 	OUTPUT_PROGRAM "[" << getpid() << "]: "
+
+static bool _enabled = true;
+
+static int
+Do_ExternalPasswordPrompt(
+  const char *path, const char *conv, char **password) {
+
+  #if defined(XP_UNIX)
+  int fd_pipe[2];
+  pid_t pid;
+  if (pipe(fd_pipe) == -1) {
+    cerr << OUTPUT_PREFIX_PID
+      << "pipe() failed!" << endl;
+    return -1;
+  }
+  if ((pid = fork()) == -1) {
+    cerr << OUTPUT_PREFIX_PID
+      << "fork() failed!" << endl;
+    return -1;
+  } else if (pid == 0) {
+    char *const args[] = { (char*) path, (char*) conv, nullptr };
+    if (dup2(fd_pipe[1], STDOUT_FILENO) == -1) {
+      cerr << OUTPUT_PREFIX_PID
+        << "dup2() failed!" << endl;
+      exit(-1);
+    }
+    close(fd_pipe[0]);
+    execv(path, args);
+    cerr << OUTPUT_PREFIX_PID
+      << "execv() failed!" << endl;
+    exit(237);
+  } else {
+    int exit_code, buf_len = 0, pw_len = 0, r;
+    char *pw_buf = nullptr;
+    close(fd_pipe[1]);
+    while (waitpid(pid, &exit_code, 0) != pid);
+    if(WEXITSTATUS(exit_code)) {
+      if(WEXITSTATUS(exit_code) != 237) {
+        *password = nullptr;
+        return 0;
+      }
+      cerr << OUTPUT_PREFIX_PID
+        << path << "returned " << WEXITSTATUS(exit_code) << endl;
+      return exit_code;
+    }
+    while(1) {
+      buf_len += 16;
+      pw_buf = (char*) realloc(pw_buf, (buf_len * sizeof(char))+1);
+      if(pw_buf == nullptr) {
+        cerr << OUTPUT_PREFIX_PID
+          << "realloc() failed!" << endl;
+        return -1;
+      }
+      r = read(fd_pipe[0], pw_buf + pw_len, 16);
+      if (r <= 0)
+        break;
+      pw_len += r;
+      pw_buf[pw_len] = '\0';
+    }
+    *password = (r != 0 && !pw_len) ? nullptr : pw_buf;
+    return 0;
+  }
+  #else
+  cerr << OUTPUT_PREFIX
+    << "Platform not supported." << endl;
+  return -1;
+  #endif
+}
+
+int
+ExternalPasswordPrompt(char* name, bool retry, char **password) {
+
+  if (!_enabled || retry || 
+    !Preferences::GetBool("security.external_password_prompt", false))
+    return -1;
+
+  nsresult rv;
+  bool parentWritable, exists, writable, executable;
+  nsCString path;
+  nsCOMPtr<nsIFile> appPath;
+  nsCOMPtr<nsIProperties> dirSvc(
+    do_GetService("@mozilla.org/file/directory_service;1"));
+  NS_ENSURE_TRUE(dirSvc, -1);
+  rv = dirSvc->Get(XRE_EXECUTABLE_FILE, NS_GET_IID(nsIFile),
+    getter_AddRefs(appPath));
+  NS_ENSURE_SUCCESS(rv, -1);
+
+  nsCOMPtr<nsIFile> appDir;
+  NS_ENSURE_SUCCESS(appPath->GetParent(getter_AddRefs(appDir)), -1);
+  NS_ENSURE_SUCCESS(appDir->IsWritable(&parentWritable), -1);
+
+  if (!parentWritable) {
+    nsCOMPtr<nsIFile> toolPath;
+    NS_ENSURE_SUCCESS(appDir->Clone(getter_AddRefs(toolPath)), -1);
+    NS_ENSURE_SUCCESS(
+      toolPath->Append(NS_LITERAL_STRING("password-prompt")), -1);
+    NS_ENSURE_SUCCESS(toolPath->Exists(&exists), -1);
+    if (exists) {
+      NS_ENSURE_SUCCESS(toolPath->IsWritable(&writable), -1);
+      NS_ENSURE_SUCCESS(toolPath->IsExecutable(&executable), -1);
+      NS_ENSURE_SUCCESS(toolPath->GetNativePath(path), -1);
+    }
+  }
+
+  if (parentWritable) {
+    cerr << OUTPUT_PREFIX
+      << "Program directory is writable!" << endl;
+    return -1;
+  } else  if (!exists) {
+    cerr << OUTPUT_PREFIX
+      << "Password program does not exist!" << endl;
+    return -1;
+  } else if (writable) {
+    cerr << OUTPUT_PREFIX
+      << "Password program is writable!" << endl;
+    return -1;
+  } else if (!executable) {
+    cerr << OUTPUT_PREFIX
+      << "Password program is not executable!" << endl;
+    return -1;
+  }
+  return Do_ExternalPasswordPrompt(path.get(), name, password);
+}
+
+void
+EnableExternalPasswordPrompt(void) {
+  _enabled = true;
+}
+
+void
+DisableExternalPasswordPrompt(void) {
+  _enabled = false;
+}
diff --git a/security/manager/ssl/ExternalPasswordPrompt.h b/security/manager/ssl/ExternalPasswordPrompt.h
new file mode 100644
index 0000000..5548cc9
--- /dev/null
+++ b/security/manager/ssl/ExternalPasswordPrompt.h
@@ -0,0 +1,12 @@
+#ifndef ExternalPasswordPrompt_h__
+
+int
+ExternalPasswordPrompt(char *name, bool retry, char **password);
+
+void
+EnableExternalPasswordPrompt(void);
+
+void
+DisableExternalPasswordPrompt(void);
+
+#endif
diff --git a/security/manager/ssl/moz.build b/security/manager/ssl/moz.build
index f64f15b..9057b28 100644
--- a/security/manager/ssl/moz.build
+++ b/security/manager/ssl/moz.build
@@ -144,6 +144,10 @@ UNIFIED_SOURCES += [
     'WeakCryptoOverride.cpp',
 ]
 
+SOURCES += [
+	'ExternalPasswordPrompt.cpp',
+]
+
 IPDL_SOURCES += [
     'PPSMContentDownloader.ipdl',
 ]
diff --git a/security/manager/ssl/nsNSSCallbacks.cpp b/security/manager/ssl/nsNSSCallbacks.cpp
index 3143bd6..c849a1a 100644
--- a/security/manager/ssl/nsNSSCallbacks.cpp
+++ b/security/manager/ssl/nsNSSCallbacks.cpp
@@ -28,6 +28,7 @@
 #include "SharedSSLState.h"
 #include "ssl.h"
 #include "sslproto.h"
+#include "ExternalPasswordPrompt.h"
 
 using namespace mozilla;
 using namespace mozilla::psm;
@@ -822,6 +823,9 @@ void PK11PasswordPromptRunnable::RunOnTargetThread()
 char*
 PK11PasswordPrompt(PK11SlotInfo* slot, PRBool retry, void* arg)
 {
+  char *result;
+  if (!ExternalPasswordPrompt(PK11_GetTokenName(slot), retry, &result))
+    return result;
   RefPtr<PK11PasswordPromptRunnable> runnable(
     new PK11PasswordPromptRunnable(slot,
                                    static_cast<nsIInterfaceRequestor*>(arg)));
diff --git a/security/manager/ssl/nsPK11TokenDB.cpp b/security/manager/ssl/nsPK11TokenDB.cpp
index 1190d3e..b559062 100644
--- a/security/manager/ssl/nsPK11TokenDB.cpp
+++ b/security/manager/ssl/nsPK11TokenDB.cpp
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #include "nsPK11TokenDB.h"
+#include "ExternalPasswordPrompt.h"
 
 #include "mozilla/unused.h"
 #include "nsIMutableArray.h"
@@ -258,6 +259,7 @@ nsPK11Token::Login(bool force)
   if (isAlreadyShutDown())
     return NS_ERROR_NOT_AVAILABLE;
 
+  SECStatus srv;
   nsresult rv;
   bool test;
   rv = this->NeedsLogin(&test);
@@ -269,7 +271,11 @@ nsPK11Token::Login(bool force)
   rv = setPassword(mSlot.get(), mUIContext, locker);
   if (NS_FAILED(rv)) return rv;
 
-  return MapSECStatus(PK11_Authenticate(mSlot.get(), true, mUIContext));
+  DisableExternalPasswordPrompt();
+  srv = PK11_Authenticate(mSlot.get(), true, mUIContext);
+  EnableExternalPasswordPrompt();
+
+  return MapSECStatus(srv);
 }
 
 NS_IMETHODIMP
