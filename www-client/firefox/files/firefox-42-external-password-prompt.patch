diff --git a/security/manager/ssl/ExternalPasswordPrompt.cpp b/security/manager/ssl/ExternalPasswordPrompt.cpp
new file mode 100644
index 0000000..f8988c1
--- /dev/null
+++ b/security/manager/ssl/ExternalPasswordPrompt.cpp
@@ -0,0 +1,168 @@
+#include "mozilla/Preferences.h"
+#include "nsCOMPtr.h"
+#include "nsIProperties.h"
+#include "nsIFile.h"
+#include "nsString.h"
+#include "nsXULAppAPI.h"
+#include "secport.h"
+#include <iostream>
+#include <string>
+#include <cstdlib>
+
+#if defined(XP_UNIX)
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <string.h>
+#include <errno.h>
+#endif
+
+using namespace std;
+using namespace mozilla;
+
+#define OUTPUT_PROGRAM			"ExternalPasswordPrompt"
+#define OUTPUT_PREFIX 			OUTPUT_PROGRAM ": "
+#define OUTPUT_PREFIX_PID 	OUTPUT_PROGRAM "[0000]: "
+
+static bool _enabled = true;
+
+static int
+Do_ExternalPasswordPrompt(
+  const char *path, const char *conv, char **password) {
+
+  #if defined(XP_UNIX)
+  int fd_pipe[2];
+  pid_t pid;
+  if (pipe(fd_pipe) == -1) {
+    cerr << OUTPUT_PREFIX_PID
+      << "pipe() failed!" << endl;
+    return -1;
+  }
+  if ((pid = fork()) == -1) {
+    cerr << OUTPUT_PREFIX_PID
+      << "fork() failed!" << endl;
+    return -1;
+  } else if (pid == 0) {
+    char *const args[] = { (char*) path, (char*) conv, nullptr };
+    if (dup2(fd_pipe[1], STDOUT_FILENO) == -1) {
+      cerr << OUTPUT_PREFIX_PID
+        << "dup2() failed!" << endl;
+      exit(-1);
+    }
+    close(fd_pipe[0]);
+    execv(path, args);
+    cerr << OUTPUT_PREFIX_PID
+      << "execv() failed!" << endl;
+    exit(237);
+  } else {
+    int exit_code, buf_len = 0, pw_len = 0, r;
+    char *pw_buf = nullptr;
+    close(fd_pipe[1]);
+    while (waitpid(pid, &exit_code, 0) != pid);
+    if(WEXITSTATUS(exit_code)) {
+      if(WEXITSTATUS(exit_code) != 237) {
+        *password = nullptr;
+        return 0;
+      }
+      cerr << OUTPUT_PREFIX_PID
+        << path << "returned " << WEXITSTATUS(exit_code) << endl;
+      return exit_code;
+    }
+    while(1) {
+      buf_len += 16;
+      pw_buf = (char*) realloc(pw_buf, (buf_len * sizeof(char))+1);
+      if(pw_buf == nullptr) {
+        cerr << OUTPUT_PREFIX_PID
+          << "realloc() failed!" << endl;
+        return -1;
+      }
+      r = read(fd_pipe[0], pw_buf + pw_len, 16);
+      if (r <= 0)
+        break;
+      pw_len += r;
+      pw_buf[pw_len] = '\0';
+    }
+    *password = (r != 0 && !pw_len) ? nullptr : pw_buf;
+    return 0;
+  }
+  #else
+  cerr << OUTPUT_PREFIX
+    << "Platform not supported." << endl;
+  return -1;
+  #endif
+}
+
+int
+ExternalPasswordPrompt(char* name, bool retry, char **password) {
+
+  if (Preferences::GetBool("security.external_password_test", false)) {
+  cerr << OUTPUT_PREFIX
+    << "Name: " << name << endl;
+
+  if (!_enabled || retry)
+    return -1;
+
+  nsresult rv;
+  bool parentWritable, exists, writable, executable;
+  nsCString path;
+  nsCOMPtr<nsIFile> appPath;
+  nsCOMPtr<nsIProperties> dirSvc(
+    do_GetService("@mozilla.org/file/directory_service;1"));
+  NS_ENSURE_TRUE(dirSvc, -1);
+  rv = dirSvc->Get(XRE_EXECUTABLE_FILE, NS_GET_IID(nsIFile),
+    getter_AddRefs(appPath));
+  NS_ENSURE_SUCCESS(rv, -1);
+
+  nsCOMPtr<nsIFile> appDir;
+  NS_ENSURE_SUCCESS(appPath->GetParent(getter_AddRefs(appDir)), -1);
+  NS_ENSURE_SUCCESS(appDir->IsWritable(&parentWritable), -1);
+
+  if (!parentWritable) {
+    nsCOMPtr<nsIFile> toolPath;
+    NS_ENSURE_SUCCESS(appDir->Clone(getter_AddRefs(toolPath)), -1);
+    NS_ENSURE_SUCCESS(
+      toolPath->Append(NS_LITERAL_STRING("password-prompt")), -1);
+    NS_ENSURE_SUCCESS(toolPath->Exists(&exists), -1);
+    if (exists) {
+      NS_ENSURE_SUCCESS(toolPath->IsWritable(&writable), -1);
+      NS_ENSURE_SUCCESS(toolPath->IsExecutable(&executable), -1);
+      NS_ENSURE_SUCCESS(toolPath->GetNativePath(path), -1);
+    }
+  }
+
+  if (parentWritable) {
+    cerr << OUTPUT_PREFIX
+      << "Program directory is writable!" << endl;
+    NS_WARNING(OUTPUT_PREFIX "Program directory is writable!");
+    return -1;
+  } else  if (!exists) {
+    cerr << OUTPUT_PREFIX
+      << "Password program does not exist!" << endl;
+    return -1;
+  } else if (writable) {
+    cerr << OUTPUT_PREFIX
+      << "Password program is writable!" << endl;
+    return -1;
+  } else if (!executable) {
+    cerr << OUTPUT_PREFIX
+      << "Password program is not executable!" << endl;
+    return -1;
+  }
+  return Do_ExternalPasswordPrompt(path.get(), name, password);
+  }
+
+  if (!Preferences::GetBool("security.external_password_prompt", false))
+    return -1;
+  return Do_ExternalPasswordPrompt("/usr/bin/ksshaskpass",
+    "Firefox/Software Security Device", password);
+}
+
+void
+EnableExternalPasswordPrompt(void) {
+  _enabled = true;
+}
+
+void
+DisableExternalPasswordPrompt(void) {
+  _enabled = false;
+}
diff --git a/security/manager/ssl/ExternalPasswordPrompt.h b/security/manager/ssl/ExternalPasswordPrompt.h
new file mode 100644
index 0000000..5548cc9
--- /dev/null
+++ b/security/manager/ssl/ExternalPasswordPrompt.h
@@ -0,0 +1,12 @@
+#ifndef ExternalPasswordPrompt_h__
+
+int
+ExternalPasswordPrompt(char *name, bool retry, char **password);
+
+void
+EnableExternalPasswordPrompt(void);
+
+void
+DisableExternalPasswordPrompt(void);
+
+#endif
diff --git a/security/manager/ssl/moz.build b/security/manager/ssl/moz.build
index d8527b5..774d0d7 100644
--- a/security/manager/ssl/moz.build
+++ b/security/manager/ssl/moz.build
@@ -130,6 +130,7 @@ UNIFIED_SOURCES += [
 
 # nsNSSCertificateDB.cpp needs to include nscert.h before everything else.
 SOURCES += [
+    'ExternalPasswordPrompt.cpp',
     'nsNSSCertificateDB.cpp',
 ]
 
diff --git a/security/manager/ssl/nsNSSCallbacks.cpp b/security/manager/ssl/nsNSSCallbacks.cpp
index e00d728..c7b7f02 100644
--- a/security/manager/ssl/nsNSSCallbacks.cpp
+++ b/security/manager/ssl/nsNSSCallbacks.cpp
@@ -24,6 +24,7 @@
 #include "SharedSSLState.h"
 #include "ssl.h"
 #include "sslproto.h"
+#include "ExternalPasswordPrompt.h"
 
 using namespace mozilla;
 using namespace mozilla::psm;
@@ -857,6 +858,9 @@ void PK11PasswordPromptRunnable::RunOnTargetThread()
 char*
 PK11PasswordPrompt(PK11SlotInfo* slot, PRBool retry, void* arg)
 {
+  char *result;
+  if (!ExternalPasswordPrompt(PK11_GetTokenName(slot), retry, &result))
+    return result;
   RefPtr<PK11PasswordPromptRunnable> runnable(
     new PK11PasswordPromptRunnable(slot,
                                    static_cast<nsIInterfaceRequestor*>(arg)));
diff --git a/security/manager/ssl/nsPK11TokenDB.cpp b/security/manager/ssl/nsPK11TokenDB.cpp
index fa25e2e..1634224 100644
--- a/security/manager/ssl/nsPK11TokenDB.cpp
+++ b/security/manager/ssl/nsPK11TokenDB.cpp
@@ -13,6 +13,7 @@
 #include "nsServiceManagerUtils.h"
 
 #include "nsPK11TokenDB.h"
+#include "ExternalPasswordPrompt.h"
 
 extern PRLogModuleInfo* gPIPNSSLog;
 
@@ -199,7 +200,9 @@ nsPK11Token::Login(bool force)
   }
   rv = setPassword(mSlot, mUIContext);
   if (NS_FAILED(rv)) return rv;
+  DisableExternalPasswordPrompt();
   srv = PK11_Authenticate(mSlot, true, mUIContext);
+  EnableExternalPasswordPrompt();
   return (srv == SECSuccess) ? NS_OK : NS_ERROR_FAILURE;
 }
 
